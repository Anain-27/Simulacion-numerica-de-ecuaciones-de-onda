% !TeX encoding = ISO-8859-1

\chapter{Anexo}
\label{cha:Anexo}
En este capítulo anexaremos el código realizado en Python.\\

\section{Resolución numérica}
Comenzamos implementando el esquema \eqref{esquemacompletoonda} y así resolviendo la ecuación de onda en ese contexto.
 \begin{verbatim}
 	import numpy as np
 	import time
 	import os as os
 	from shutil import rmtree
 	import matplotlib.pyplot as plt
 	
 	#Funciones necesarias
 	
 	# Para inicializar los valores iniciales que dependen de la
 	 derivada lo haremos con una aproximación progresiva del 
 	 tiempo definimos la funcion g del esquema.
 	
 	def g(x):
 	return 0
 	
 	
 	'''
 	# En este caso tomamos una condición tipo struck en 0.4,
 	 0.5 max
 	def g(x):
 	if( x<=0.4):
 	return 2.5*x
 	else:
 	return -(10/6)*x
 	'''
 	
 	'''
 	# En este caso tomamos una condición tipo struck en 0.1, 
 	1 max
 	
 	def g(x):
 	if( x<=0.1):
 	return 50000*x
 	if (x <= 0.2):
 	return 50000*(0.2-x)
 	else:
 	return 0
 	'''
 	
 	'''
 	# En este caso tomamos una condición tipo crc c0=1000, 
 	x0 = 0.5
 	
 	def g(x):
 	if (0.4<=x <= 0.6):
 	return 1000/2 * (1+np.cos(np.pi*(x-0.4)/0.1))
 	else:
 	return 0
 	'''
 	
 	
 	# Condición de contorno en el eje de posición tipo seno
 	
 	def f(x):
 	aux = []
 	for i in x:
 	aux.append(np.sin(2*np.pi*i))
 	return aux # Tener cuidado con la función por si se sale
 				 del rango
 	
 	
 	'''
 	#Condición de contorno en el eje de posición tipo pico
 	def f(x):
 	aux = []
 	for i in x:
 	if( i<=0.25):
 	aux.append(0)
 	elif ( i<=0.5):
 	aux.append(4*(i-0.25))
 	elif ( i<=0.75):
 	aux.append(4*(0.75-i))
 	else:
 	aux.append(0)
 	return aux
 	'''
 	
 	'''
 	#Condición de contorno en el eje de posición tipo trapecio
 	def f(x):
 	aux = []
 	for i in x:
 	if( i<=0.1):
 	aux.append(0)
 	elif ( i<=0.3):
 	aux.append(5*i-0.5)
 	elif ( i<=0.7):
 	aux.append(1)
 	elif ( i<=0.9):
 	aux.append(-5*i+4.5)
 	else:
 	aux.append(0)
 	return aux
 	'''
 	
 	'''
 	#condicioón de tipo c_rc con x_hw= 0.2 x_0 = 0.5 c_0= 1
 	def f(x):
 	aux = []
 	for i in x:
 	if( i<=0.3):
 	aux.append(0)
 	elif ( i<=0.7):
 	aux.append((1+np.cos(np.pi * (i-0.5)/0.2))/2)
 	
 	else:
 	aux.append(0)
 	return aux
 	'''
 	
 	'''
 	# Condición de contorno en el eje de posición tipo plano
 	def f(x):
 	lon = len(x)
 	return np.zeros(lon)
 	'''
 	
 	# Definimos una función para usar en el método explícito y 
 	poder cambiarlo de manera rápida si hace falta
 	def Explicito(x1, x2, x3, x4,mu):  # Si queremos hacerlo 
 										en un file independiente 
 										tendremos que añadir el mu
 	return  mu ** 2 * (x1 + x2) + 2 * (1- mu ** 2) * x3 - x4
 	
 	
 	start = time.time()
 	print("Vamos a hacer una resolución numérica de la ecuación de
 	 onda u_tt-c^2u_xx=0")
 	print("Introduce c:")
 	c= float(input())
 	print("Introduce el nombre del directorio donde quieres guardar 
 	los archivos:")
 	directorio=input()
 	
 	
 	#Creamos una carpeta en la que se guardarán los datos
 	home = 'C:\\Users\\Ana Cuevas de Cózar\\PycharmProjects\\
 	pythonProject2'
 	directoriofinal=home+'\\'+directorio+'\\'
 	
 	#Si existe el directorio lo borra
 	try:
 	rmtree(directoriofinal)
 	except:
 	print('No existía el directorio, lo creamos')
 	os.mkdir(directoriofinal)
 	
 	
 	#Constantes necesarias
 	l=1
 	tmax= 1
 	m = int(l*300) #Constante representativa del número de trozos
 					en los que separamos el espacio
 	h=l/m  #Cambiamos la h para que sea entera
 	
 	k =h/c #Lo tomamos de esta forma para ganar en exactitud pagina
 			 133 numerical sound synthesis
 	
 	
 	#Cambiamos k para hacer las comparaciones
 	'''
 	k =h/c * 0.9
 	k =h/c * 0.5
 	k =h/c * 0.1
 	k =h/c * 0.01
 	k =1.001*h/c
 	k =1.005*h/c
 	'''
 	
 	n= int(tmax/k)
 	mu = c * k / h
 	
 	if mu>1 :
 	    raise Exception('Mu es mayor que 1')
 	print(f'n{n}, c{c}, k{k}, h{h}, m{m}, mu{mu}')
 	
 	# Creamos un mallado de puntos en los que aproximaremos la 
 	solución
 	x= np.linspace(0,l,num=m +1)
 	t= np.linspace(0,tmax,num=n +1)
 	
 	
 	
 	# Creamos la matriz u de soluciones u(x,t)
 	u = np.empty((m + 1, n + 1), float)
 	
 	
 	# Añadimos antes que nada los nodos conocidos por las 
 	condiciones de contorno
 	u[:, 0] = f(x)
 	
 	u[0, :] = np.zeros(n + 1)
 	
 	u[m, :] = np.zeros(n + 1)
 	aux=[0]
 	
 	
 	# Para inicializar los valores iniciales que dependen 
 	de la derivada lo haremos con una aproximación progresiva
 	del tiempo
 	
 	for i in range(1, m):
 		u[i, 1] = u[i, 0] + k * g(x[i])
 		aux.append(g(x[i]))
 	
 	aux.append(g(x[m]))
 	
 	
 	for j in range(2, n + 1):
 		u[1:m, j] = Explicito(u[2:m+1,j-1], u[0:m-1,j-1], 
 		u[1:m,j-1], u[1:m,j-2],mu)
 	
 	
 	#Implementamos la solución de tipo onda viajera.
 	Solo para mu=1
 	
 	# Creamos la matriz wl la solución viajera hacia la 
 	izquierda y wr hacia la derecha
 	
 	wl = np.empty((m + 1, n + 1), float) #Solo para mu=1
 	wr = np.empty((m + 1, n + 1), float) #Solo para mu=1
 	
 	#Inicializamos la solución
 	for i in range(0, m+1):
 		if i==0:
 			sumx =2* g(x[0])
 		elif i==1:
 			sumx = g(x[0])+g(x[1])
 		else:
 			sumx += g(x[i-1])+g(x[i])
 		wl[i, 0] = 1 / 2 * f([x[i]])[0] + h / (4 * c) * (sumx)
 		 + k / 4 * 2*g(x[i]+c*t[0]) #Prueba apendice libro Bilbao
 		 
 	wr[0:m+1,0]=wl[0:m+1,0]
 	
 	
 	for j in range(1, n + 1):
 		temp1 = wr[m,j-1]
 		temp2 = wl[0,j-1]
 		wr[1:m+1,j] = wr[0:m,j-1]
 		wl[0:m ,j] = wl[1:m+1,j-1]
 		wr[0,j] = -temp2
 		wl[m,j] = -temp1
 	
 	#Termina la parte de la solución de tipo onda viajera
 	
 	end = time.time()
 	
 	
 	plt.plot(x,aux,'k')
 	plt.xlabel('x')
 	plt.ylabel('g(x)')
 	plt.title(f'G')
 	plt.savefig(directoriofinal+'prueba g.png')
 	plt.close()
 	
 	print(f'Ha tardado {np.floor(end-start)} segundos.')
 	np.save(directoriofinal+'u', u)
 	np.save(directoriofinal+'x', x)
 	np.save(directoriofinal+'t', t)
 	
 	
 	np.save(directoriofinal+'wl', wl) #Solo para mu=1
 	np.save(directoriofinal + 'wr', wr) #Solo para mu=1
 	
 	
 	np.save(directoriofinal+'constantes', [c, m,h,n,k,mu,tmax,l] ) 
 	#Guardar en cons las constantes que necesitemos para usarlas luego
 	en el guardado del sonido
 	
 \end{verbatim}
 Al final guardamos los datos obtenidos para su posterior procesado.
 
\section{Wave}
Creo ahora un archivo de audio a partir de los datos anteriores y lo guardo en un archivo de sonido .wav
\begin{verbatim}
	import numpy as np
	from scipy.io.wavfile import write
	
	
	print("Vamos a guardar nuestros datos en formato wav")
	print("Introduce el nombre de la carpeta:")
	dir= str(input())
	
	
	#Creamos el directorio
	directorio='C:\\Users\\Ana Cuevas de Cózar\\PycharmProjects
	\\pythonProject2\\'+dir+'\\'
	
	
	#Añadimos los datos
	datos = np.load(directorio+'u.npy', mmap_mode='r')
	t = np.load(directorio+'t.npy', mmap_mode='r')
	x = np.load(directorio+'x.npy', mmap_mode='r')
	[f, m1,h1,n1,k1,mu,tmax]= np.load(directorio+'constantes.npy',
	 mmap_mode='r')
	
	m1=int(m1)
	n1=int(n1)
	
	#Constantes necesarias
	sample_rate = 44100
	n2 = int(tmax*sample_rate)
	t_necesario= np.linspace(0,tmax,n2 +1)
	
	
	# Escogiendo un punto en particular
	Comprobamos donde está el punto de mayor amplitud en el
	instante inicial y en ese punto es donde veremos como 
	se mueve la onda.
	pos_readout= np.where(datos[:,0]==max(datos[:,0]))[0][0]
	
	if pos_readout==0:
		pos_readout= 50
		print('Cambio la posicion a 0.5')
	
	wave_table = datos[pos_readout] # Elijo un punto en el 
	espacio en el que veremos el movimiento de la cuerda
	
	wave_table2 = datos[pos_readout+1] # Elijo un punto en el
	espacio en el que veremos el movimiento de la cuerda
	output = np.interp(t_necesario,  t, wave_table)
	
	
	# Sumando todos los puntos en espacio que tenemos.
	#wave_table = np.zeros(n1 + 1)
	#for i in range(0, m1+1):
	#wave_table += datos[i, :]
	
	#wave_table= wave_table/(m1+1)
	#output = np.interp(t_necesario,  t, wave_table)
	
	
	#Vamos a modificar los limites para que suene a un nivel
	# de volumen adecuado, para ello teben ser en torno al 
	# orden e-1 o e-2
	#gain= 0
	#amplitud = 10** (gain/20)
	#output *=amplitud
	
	
	# Para que al principio y final se escuche mas suave
	#output = fade(output)
	
	#Guardamos
	write(directorio+f'Sonido.wav',sample_rate,output)
\end{verbatim}

\section{Imágenes}
Creamos y guardamos las imágenes de la posición de la cuerda en varios instantes de tiempo y de los cambios de posición de la onda en un punto del eje $X$ durante un periodo de tiempo.

\begin{verbatim}
	import numpy as np
	import matplotlib.pyplot as plt
	from os import mkdir
	from shutil import rmtree
	
	print("Vamos a guardar nuestras imagenes")
	print("Introduce el nombre de la carpeta:")
	dir= str(input())
	
	
	#Creamos los directorios
	directorio='C:\\Users\\Ana Cuevas de Cózar\\PycharmProjects\\
	pythonProject2\\'+dir+'\\'
	cuerda=directorio + 'Imagenes Cuerda\\'
	onda= directorio+ 'Imagenes Onda\\'
	
	try:
	rmtree(cuerda)
	rmtree(onda)
	except:
	print('No existían las imagenes, las creamos')
	mkdir(onda)
	mkdir(cuerda)
	
	
	
	#Añadimos los datos
	datos = np.load(directorio+'u.npy', mmap_mode='r')
	
	#Solo para ondas viajeras, para mu=1
	datoswl = np.load(directorio+'wl.npy', mmap_mode='r') #Solo para mu=1
	datoswr = np.load(directorio+'wr.npy', mmap_mode='r') #Solo para mu=1
	
	
	t = np.load(directorio+'t.npy', mmap_mode='r')
	x = np.load(directorio+'x.npy', mmap_mode='r')
	[f, m,h,n,k,mu,tmax]= np.load(directorio+'constantes.npy', 
	mmap_mode='r')
	
	n=int(n)
	m=int(m)
	
	#Vamos a pintar las imagenes de a posición de la cuerda en
	 instantes selecionados
	plt.plot(x, datos[:, 0], 'k')
	
	plt.plot(x, datoswl[:, 0], 'r') #Solo para mu=1
	plt.plot(x, datoswr[:, 0], 'b') #Solo para mu=1
	
	plt.ylim(-1,1)
	plt.xlabel('x')
	plt.ylabel('u')
	plt.title(f'Cuerda en el instante {t[0]},\nmin={min(datos[:,0])},
	 max={max(datos[:,0])}')
	plt.savefig(cuerda+f'Cuerda_instante_{0}.png')
	plt.close()
	
	
	#Elegimos cuantas imagenes pintar, al menos un ciclo completo.
	if (int(2*n/f)+2)/100 > 1:
	aux=int((int(2*n/f)+2)/100)
	else:
	aux=1
	
	
	for j in range(1, 2*int(2*n/f)+2):
		if j %aux ==0 :
		plt.plot(x, datos[:, j], 'k')
		plt.ylim(-1,1)
		plt.xlabel('x')
		plt.ylabel('u')
		plt.title(f'Cuerda en el instante {t[j]},\nmin={min(datos[:,j])},
		max={max(datos[:,j])}')
		
		plt.savefig(cuerda+f'Cuerda_instante_{j}.png')
		plt.close()
	
	
	#Pintamos la imagen de la onda en los 1000 primeros instantes
	en cada punto
	for j in range(0, m + 1):
		plt.plot(t[0:10*int(2*n/f)+2], datos[j,0:10*int(2*n/f)+2],'r')
		plt.ylim(-1.1, 1.1)
		plt.xlabel('t')
		plt.ylabel('u')
		plt.title(f'Movimiento del punto {x[j]} en el espacio')  #axis tight
		plt.savefig(onda+f'PrimerosmilPunto_{j}.png')
		plt.close()
		
		plt.plot(t[0:10*int(2*n/f)+2], datos[j, n - (10*int(2*n/f)+2):n], 'b')
		plt.ylim(-1.1, 1.1)
		plt.xlabel('t')
		plt.ylabel('u')
		plt.title(f'Movimiento del punto {x[j]} en el espacio')  # axis tight
		plt.savefig(onda + f'UltimosmilPunto_{j}.png')
		plt.close()
\end{verbatim}

% ----------------------------------------------------------------------

 